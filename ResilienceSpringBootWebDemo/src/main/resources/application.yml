server:
  port: 8080

management:
  health:
    circuitbreakers:
      enabled: true
  endpoints:
    web:
      exposure:
        include: '*'
  endpoint:
    health:
      show-details: always

resilience4j:
  retry:
    instances:
      retryApi:
        maxAttempts: 3
        waitDuration: 1s
    metrics:
      enabled: true
      legacy:
        enabled: true
  circuitbreaker:
    instances:
      example:
        registerHealthIndicator: true
        failureRateThreshold: 50
        automaticTransitionFromOpenToHalfOpenEnabled: true
        waitDurationInOpenState: 5s
        permittedNumberOfCallsInHalfOpenState: 3
        slidingWindowSize: 3
        slidingWindowType: COUNT_BASED
        slowCallRateThreshold: 40
        slowCallDurationThreshold: 2s
  timelimiter:
    metrics:
      enabled: true
    instances:
      timeLimiterApi:
        timeoutDuration: 2s
        cancelRunningFuture: false


#resilience4j.retry:
#  instances:
#    backendA:
#      maxAttempts: 3
#      waitDuration: 10s
#      enableExponentialBackoff: true
#      exponentialBackoffMultiplier: 2
#      retryExceptions:
#        - org.springframework.web.client.HttpServerErrorException
#        - java.io.IOException
#      ignoreExceptions:
#        - io.github.robwin.exception.BusinessException
#    backendB:
#      maxAttempts: 3
#      waitDuration: 10s
#      retryExceptions:
#        - org.springframework.web.client.HttpServerErrorException
#        - java.io.IOException
#      ignoreExceptions:
#        - io.github.robwin.exception.BusinessException
#
#resilience4j.bulkhead:
#  instances:
#    backendA:
#      maxConcurrentCalls: 10
#    backendB:
#      maxWaitDuration: 10ms
#      maxConcurrentCalls: 20
#
#resilience4j.thread-pool-bulkhead:
#  instances:
#    backendC:
#      maxThreadPoolSize: 1
#      coreThreadPoolSize: 1
#      queueCapacity: 1
#      writableStackTraceEnabled: true
#
#resilience4j.ratelimiter:
#  instances:
#    backendA:
#      limitForPeriod: 10
#      limitRefreshPeriod: 1s
#      timeoutDuration: 0
#      registerHealthIndicator: true
#      eventConsumerBufferSize: 100
#    backendB:
#      limitForPeriod: 6
#      limitRefreshPeriod: 500ms
#      timeoutDuration: 3s
#
#resilience4j.timelimiter:
#  instances:
#    backendA:
#      timeoutDuration: 2s
#      cancelRunningFuture: true
#    backendB:
#      timeoutDuration: 1s
#      cancelRunningFuture: false